
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_tutorials/cov2d_simulation.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_auto_tutorials_cov2d_simulation.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_tutorials_cov2d_simulation.py:


2D Covariance Estimation
========================

This script illustrates 2D covariance Wiener filtering functionality in the
ASPIRE package, implemented by estimating the covariance of the unfiltered
images in a Fourier-Bessel basis and applying the Wiener filter induced by
that covariance matrix.

.. GENERATED FROM PYTHON SOURCE LINES 10-34

.. code-block:: default


    import logging
    import os

    import matplotlib.pyplot as plt
    import numpy as np

    from aspire.basis import FFBBasis2D
    from aspire.covariance import RotCov2D
    from aspire.operators import RadialCTFFilter, ScalarFilter
    from aspire.source.simulation import Simulation
    from aspire.utils import anorm
    from aspire.volume import Volume

    logger = logging.getLogger(__name__)

    DATA_DIR = "data"


    logger.info(
        "This script illustrates 2D covariance Wiener filtering functionality in ASPIRE package."
    )






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    2022-12-13 04:00:21,281 INFO This script illustrates 2D covariance Wiener filtering functionality in ASPIRE package.




.. GENERATED FROM PYTHON SOURCE LINES 35-37

Image Formatting
----------------

.. GENERATED FROM PYTHON SOURCE LINES 37-47

.. code-block:: default


    # Set the sizes of images 64 x 64
    img_size = 64
    # Set the total number of images generated from the 3D map
    num_imgs = 1024
    # Set dtype for this experiment
    dtype = np.float32
    logger.info(f"Simulation running in {dtype} precision.")






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    2022-12-13 04:00:21,283 INFO Simulation running in <class 'numpy.float32'> precision.




.. GENERATED FROM PYTHON SOURCE LINES 48-53

Build Noise Filter
------------------
Set the noise variance and build the noise filter
It might be better to select a signal noise ratio
and initial noise inside the Simulation class.

.. GENERATED FROM PYTHON SOURCE LINES 53-57

.. code-block:: default


    noise_var = 1.3957e-4
    noise_filter = ScalarFilter(dim=2, value=noise_var)








.. GENERATED FROM PYTHON SOURCE LINES 58-60

Specify the CTF Parameters
--------------------------

.. GENERATED FROM PYTHON SOURCE LINES 60-69

.. code-block:: default


    pixel_size = 5 * 65 / img_size  # Pixel size of the images (in angstroms)
    voltage = 200  # Voltage (in KV)
    defocus_min = 1.5e4  # Minimum defocus value (in angstroms)
    defocus_max = 2.5e4  # Maximum defocus value (in angstroms)
    defocus_ct = 7  # Number of defocus groups.
    Cs = 2.0  # Spherical aberration
    alpha = 0.1  # Amplitude contrast








.. GENERATED FROM PYTHON SOURCE LINES 70-72

Initialize Simulation Object and CTF Filters
--------------------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 72-105

.. code-block:: default


    logger.info("Initialize simulation object and CTF filters.")
    # Create filters
    ctf_filters = [
        RadialCTFFilter(pixel_size, voltage, defocus=d, Cs=2.0, alpha=0.1)
        for d in np.linspace(defocus_min, defocus_max, defocus_ct)
    ]

    # Load the map file of a 70S Ribosome
    logger.info(
        f"Load 3D map and downsample 3D map to desired grids "
        f"of {img_size} x {img_size} x {img_size}."
    )
    vols = Volume.load(os.path.join(DATA_DIR, "clean70SRibosome_vol_65p.mrc"), dtype=dtype)

    # Scale and downsample
    vols[0] /= np.max(vols[0])
    vols = vols.downsample(img_size)

    # Create a simulation object with specified filters and the downsampled 3D map
    logger.info("Use downsampled map to creat simulation object.")
    sim = Simulation(
        L=img_size,
        n=num_imgs,
        vols=vols,
        unique_filters=ctf_filters,
        offsets=0.0,
        amplitudes=1.0,
        dtype=dtype,
        noise_filter=noise_filter,
    )






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    2022-12-13 04:00:21,284 INFO Initialize simulation object and CTF filters.
    2022-12-13 04:00:21,285 INFO Load 3D map and downsample 3D map to desired grids of 64 x 64 x 64.
    2022-12-13 04:00:21,886 INFO Use downsampled map to creat simulation object.
    2022-12-13 04:00:21,887 INFO Creating Simulation with 1024 images.
    2022-12-13 04:00:21,901 INFO Appending a NoiseAdder to generation pipeline




.. GENERATED FROM PYTHON SOURCE LINES 106-108

Build Clean and Noisy Projection Images
---------------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 108-129

.. code-block:: default


    # Specify the fast FB basis method for expanding the 2D images
    ffbbasis = FFBBasis2D((img_size, img_size), dtype=dtype)

    # Assign the CTF information and index for each image
    h_idx = sim.filter_indices

    # Evaluate CTF in the 8X8 FB basis
    h_ctf_fb = [filt.fb_mat(ffbbasis) for filt in ctf_filters]

    # Get clean images from projections of 3D map.
    logger.info("Apply CTF filters to clean images.")
    imgs_clean = sim.projections[:]
    imgs_ctf_clean = sim.clean_images[:]
    power_clean = imgs_ctf_clean.norm() ** 2 / imgs_ctf_clean.size
    sn_ratio = power_clean / noise_var
    logger.info(f"Signal to noise ratio is {sn_ratio}.")

    # get noisy images after applying CTF and noise filters
    imgs_noise = sim.images[:num_imgs]





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    2022-12-13 04:00:21,902 INFO Expanding 2D image in a frequency-domain Fourierâ€“Bessel basis using the fast method.
    2022-12-13 04:00:22,281 INFO Apply CTF filters to clean images.
    2022-12-13 04:00:22,307 INFO Trying NFFT backend cufinufft
    2022-12-13 04:00:22,309 INFO NFFT backend cufinufft not usable:
            No module named 'pycuda'
    2022-12-13 04:00:22,309 INFO Trying NFFT backend finufft
    2022-12-13 04:00:22,356 INFO NFFT backend finufft usable.
    2022-12-13 04:00:22,356 INFO Trying NFFT backend pynfft
    2022-12-13 04:00:22,356 INFO NFFT backend pynfft not usable:
            No module named 'pynfft'
    2022-12-13 04:00:22,356 INFO Selected NFFT backend = finufft.
    2022-12-13 04:00:27,247 INFO Signal to noise ratio is 1.8320394012233778.




.. GENERATED FROM PYTHON SOURCE LINES 130-138

Expand Images in the Fourier-Bessel Basis
-----------------------------------------
Expand the images, both clean and noisy, in the Fourier-Bessel basis. This
can be done exactly (that is, up to numerical precision) using the
``basis.expand`` function, but for our purposes, an approximation will do.
Since the basis is close to orthonormal, we may approximate the exact
expansion by applying the adjoint of the evaluation mapping using
``basis.evaluate_t``.

.. GENERATED FROM PYTHON SOURCE LINES 138-143

.. code-block:: default


    logger.info("Get coefficients of clean and noisy images in FFB basis.")
    coeff_clean = ffbbasis.evaluate_t(imgs_clean)
    coeff_noise = ffbbasis.evaluate_t(imgs_noise)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    2022-12-13 04:00:34,028 INFO Get coefficients of clean and noisy images in FFB basis.




.. GENERATED FROM PYTHON SOURCE LINES 144-156

Create Cov2D Object and Calculate Mean and Variance for Clean Images
--------------------------------------------------------------------
Create the Cov2D object and calculate mean and covariance for clean images without CTF.
Given the clean Fourier-Bessel coefficients, we can estimate the symmetric
mean and covariance. Note that these are not the same as the sample mean and
covariance, since these functions use the rotational and reflectional
symmetries of the distribution to constrain to further constrain the
estimate. Note that the covariance matrix estimate is not a full matrix,
but is block diagonal. This form is a consequence of the symmetry
constraints, so to reduce space, only the diagonal blocks are stored. The
mean and covariance estimates will allow us to evaluate the mean and
covariance estimates from the filtered, noisy data, later.

.. GENERATED FROM PYTHON SOURCE LINES 156-164

.. code-block:: default


    logger.info(
        "Get 2D covariance matrices of clean and noisy images using FB coefficients."
    )
    cov2d = RotCov2D(ffbbasis)
    mean_coeff = cov2d.get_mean(coeff_clean)
    covar_coeff = cov2d.get_covar(coeff_clean, mean_coeff, noise_var=0)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    2022-12-13 04:00:36,819 INFO Get 2D covariance matrices of clean and noisy images using FB coefficients.




.. GENERATED FROM PYTHON SOURCE LINES 165-173

Estimate mean and covariance for noisy images with CTF and shrink method
------------------------------------------------------------------------
We now estimate the mean and covariance from the Fourier-Bessel
coefficients of the noisy, filtered images. These functions take into
account the filters applied to each image to undo their effect on the
estimates. For the covariance estimation, the additional information of
the estimated mean and the variance of the noise are needed. Again, the
covariance matrix estimate is provided in block diagonal form.

.. GENERATED FROM PYTHON SOURCE LINES 173-194

.. code-block:: default


    covar_opt = {
        "shrinker": "frobenius_norm",
        "verbose": 0,
        "max_iter": 250,
        "iter_callback": [],
        "store_iterates": False,
        "rel_tolerance": 1e-12,
        "precision": "float64",
        "preconditioner": "identity",
    }
    mean_coeff_est = cov2d.get_mean(coeff_noise, h_ctf_fb, h_idx)
    covar_coeff_est = cov2d.get_covar(
        coeff_noise,
        h_ctf_fb,
        h_idx,
        mean_coeff_est,
        noise_var=noise_var,
        covar_est_opt=covar_opt,
    )





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    2022-12-13 04:00:37,211 WARNING Left side b after removing noise in Cov2D is not positive semidefinite.
    2022-12-13 04:00:37,441 WARNING Covariance matrix in Cov2D is not positive semidefinite.
    2022-12-13 04:00:37,441 INFO Convert matrices to positive semidefinite.




.. GENERATED FROM PYTHON SOURCE LINES 195-201

Estimate Fourier-Bessel Coefficients with Wiener Filter
-------------------------------------------------------
Estimate the Fourier-Bessel coefficients of the underlying images using a
Wiener filter. This Wiener filter is calculated from the estimated mean,
covariance, and the variance of the noise. The resulting estimator has
the lowest expected mean square error out of all linear estimators.

.. GENERATED FROM PYTHON SOURCE LINES 201-215

.. code-block:: default


    logger.info("Get the CWF coefficients of noising images.")
    coeff_est = cov2d.get_cwf_coeffs(
        coeff_noise,
        h_ctf_fb,
        h_idx,
        mean_coeff=mean_coeff_est,
        covar_coeff=covar_coeff_est,
        noise_var=noise_var,
    )

    # Convert Fourier-Bessel coefficients back into 2D images
    imgs_est = ffbbasis.evaluate(coeff_est)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    2022-12-13 04:00:37,461 INFO Get the CWF coefficients of noising images.




.. GENERATED FROM PYTHON SOURCE LINES 216-218

Evaluate the Results
--------------------

.. GENERATED FROM PYTHON SOURCE LINES 218-256

.. code-block:: default


    # Calculate the difference between the estimated covariance and the "true"
    # covariance estimated from the clean Fourier-Bessel coefficients.
    covar_coeff_diff = covar_coeff - covar_coeff_est

    # Calculate the deviation between the clean estimates and those obtained from
    # the noisy, filtered images.
    diff_mean = anorm(mean_coeff_est - mean_coeff) / anorm(mean_coeff)
    diff_covar = covar_coeff_diff.norm() / covar_coeff.norm()

    # Calculate the normalized RMSE of the estimated images.
    nrmse_ims = (imgs_est - imgs_clean).norm() / imgs_clean.norm()
    logger.info(f"Deviation of the noisy mean estimate: {diff_mean}")
    logger.info(f"Deviation of the noisy covariance estimate: {diff_covar}")
    logger.info(f"Estimated images normalized RMSE: {nrmse_ims}")

    # plot the first images at different stages
    idm = 0
    plt.subplot(2, 2, 1)
    plt.imshow(-imgs_noise[idm], cmap="gray")
    plt.colorbar()
    plt.title("Noise")
    plt.subplot(2, 2, 2)
    plt.imshow(imgs_clean[idm], cmap="gray")
    plt.colorbar()
    plt.title("Clean")
    plt.subplot(2, 2, 3)
    plt.imshow(imgs_est[idm], cmap="gray")
    plt.colorbar()
    plt.title("Estimated")
    plt.subplot(2, 2, 4)
    plt.imshow(imgs_est[idm] - imgs_clean[idm], cmap="gray")
    plt.colorbar()
    plt.title("Clean-Estimated")
    plt.tight_layout()

    # Basic Check
    assert nrmse_ims < 0.25



.. image-sg:: /auto_tutorials/images/sphx_glr_cov2d_simulation_001.png
   :alt: Noise, Clean, Estimated, Clean-Estimated
   :srcset: /auto_tutorials/images/sphx_glr_cov2d_simulation_001.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    2022-12-13 04:00:38,495 INFO Deviation of the noisy mean estimate: 0.01799766533076763
    2022-12-13 04:00:38,495 INFO Deviation of the noisy covariance estimate: 0.04627946764230728
    2022-12-13 04:00:38,495 INFO Estimated images normalized RMSE: 0.17984959483146667





.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  18.677 seconds)


.. _sphx_glr_download_auto_tutorials_cov2d_simulation.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example


    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: cov2d_simulation.py <cov2d_simulation.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: cov2d_simulation.ipynb <cov2d_simulation.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
